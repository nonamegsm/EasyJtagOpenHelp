<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Understanding NAND Flash</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="assets/css/default.css" type="text/css" />
</head>
<body>
  <h1>Understanding NAND Flash</h1>
  <h2>What is NAND Flash?</h2>
  <p><strong>NAND Flash</strong> is a type of non-volatile storage technology that does not require power to retain data. An everyday example would be a mobile phone, with the NAND Flash (or the memory chip as it’s sometime called) being where data files such as photos, videos and music are stored on a microSD card. NAND flash chips are roughly the size of a finger nail and can retain huge amounts of data.</p>
  <h2>Where is it used?</h2>
  <p>NAND is primarily found in memory Cards, USB flash drives, solid state drives.  NAND Flash is all around us – in our smartphones, in modern televisions and in the computers and tablets in our homes and offices. It is also found outside, in all sorts of equipment from traffic lights to digital advertising panels, passenger announcement systems and displays. Anything that has artificial intelligence (AI) and needs to transfer and retain data is likely to contain NAND Flash.</p>
  <p> </p>
  <p>NAND Flash is available in different grades; industrial and consumer. There are significant differences between industrial and consumer grade NAND, so it is important to consider the impacts these differences have on reliability, endurance, compliance and total cost of ownership (TCO) before selecting the NAND Flash that is fit for purpose in your application.</p>
  <h2>Why is it used?</h2>
  <p>Devices made using NAND Flash offer mechanical shock resistance, high durability and are able to withstand high pressure and temperature when compared to traditional hard disk drives. There are no mvoing parts unlike HDD’s so are ideal for systems that vibrate and shake. NAND also offers fast read access times whic is crucial when processing lots of data.</p>
  <h2>What are its limitations?</h2>
  <p>NAND has a finite number of read/write cycles in a specific block (each time a bit is written or erased constitutes a program/erase cycle). Once a device reaches the user and is in operation (following manufacturer early life failure tests) its first day is always its best. NAND failure is inevitable once the program erase cycles limit is reached. Individual cells fail and overall performance degrades, a concept known as wear-out.</p>
  <h2>Why is wear-out important?</h2>
  <p>When the NAND fails the device becomes unusable, resulting in the loss of data and application functionality.</p>
  <p> </p>
  <p>How can I prevent this happening?<br />
    The simple answer is you can’t! Advanced wear leveling, over provisioning and firmware algorithms can all help to increase NAND endurance. However the best method is to understand your data usage and what the limitations are of each type of NAND used. Together with endurance technology you can protect your applications functionality and data.</p>
  <h2>How is NAND made?</h2>
  <p>The way that NAND Flash is made can have a dramatic outcome on the performance characteristics.</p>
  <p> </p>
  <p>NAND Flash goes through over 800 different manufacturing processes and it takes around 30 days to make just one wafer (which is the size of a large pizza, typically 300mm in diameter, see image right). NAND factories or ‘FABS’ are huge, run 24/7, 365 days a year for maximum efficiency and are 100 times cleaner than hospital operating theatres. FABS can make different types of NAND Flash (SLC, MLC, 3D – more on that below) and come in different sizes. Some of the largest FABS can make over 100,000 wafers a month.</p>
  <p> </p>
  <p>Once the wafer is divided, or cut into separate chips, these are analysed and graded as 1,2,3 or 4, with 1 being the highest quality. The chips are then shipped to a vendor, such as Kingston Technology, who use the NAND in their own products. The highest quality chips will have the best performance characteristics and a therefore a price premium.</p>
  <h2>Differences between NAND Flash types</h2>
  <p>There are pros and cons for each type of NAND Flash. SLC holds less data but is very fast and has the highest endurance. It is however the most expensive. Other types of NAND can hold more data and are cheaper but have much lower endurance levels and are often slower. So, when deciding which NAND flash is suitable for an application it is important to carefully consider these characteristics and their impact on application performance.</p>
  <p> </p>
  <p>Probably the key differentiator between NAND types is the endurance or Programme Erase (P/E) cycles. Due to the way NAND Flash memory works, it is required that a cell is erased before it can be written to. The process of erasing and then writing a cell is called a P/E cycle. Each time a cell is erased it is damaged or worn out, so there is a lifetime for each cell. This is exacerbated by the makeup of NAND Flash. A cell can only be erased as a block and is written as a page. The size of each block and page is dictated by the design of the NAND Flash chip, but a block consists of many pages. If information in a cell changes, it is written to a different cell and the old data marked as ‘ready for deletion’. Then, the ‘good’ data in a block is moved elsewhere and the whole block erased.</p>
  <p> </p>
  <p>So, often even if data in a cell does not change it will still go through a P/E cycle. Cells are worn as equally as possible using wear-levelling technology. This whole process increases the number of P/E cycles and ensures that the NAND Flash does not fill up with redundant data. The lifetime of the device is defined as endurance and is proportional to the P/E cycles of the NAND Flash. Remember earlier about storing bits of data in each cell?</p>
  <p> </p>
  <p>In comparing the different types of NAND the typical P/E cycles are as follows:</p>
  <p> </p>
  <p>SLC 60,000<br />
    MLC 1,500 to 3,000 (lower endurance for consumer/higher for industrial)<br />
    3D TLC 500 to 3,000 (lower endurance for consumer/higher for industrial)<br />
    As can be seen, there is a considerable difference in NAND endurance and selecting the wrong type will have an impact on application performance.</p>
  <p> </p>
  <p>Bridging the Gap with pLSC (SLC mode)</p>
  <p> </p>
  <p>SLC mode is a hybrid of 2 bit per cell MLC using intelligent firmware to emulate the storage states of SLC. This results in increased endurance on MLC (20-30K P/E cycles) at only at a fraction of the cost when compared to SLC. For industrial applications where cost and reliability are of equal importance this offers good middle ground. In the marketplace SLC mode is often referred to as pSLC and some manufacturers have their own brand name, such as iSLC and aMLC, but essentially these are all the same thing. </p>
  <h2>What is 3D NAND?</h2>
  <p>3D NAND  is a new player in the NAND Flash market. Although the concept of 3D NAND is not new (it has been around for almost a decade) it has  only made its way into the market in a big way in the last couple of years. It is arguably the biggest NAND development since its inception in the 1980s but getting 3D NAND to work consistently has been an issue. However, these challenges have now been overcome and 3D NAND will doubtless be the NAND Flash of choice for years to come.</p>
  <p> </p>
  <p>In layman’s terms 3D NAND is the stacking of memory chips on top of each other. Some manufacturers call this V (for vertical) NAND. The aim of this NAND is to make applications and devices run faster and more efficiently, hold more information and use less energy. The first company to launch 3D NAND was Samsung, a household name and by far the world’s largest NAND Flash manufacturer, with over 40 % of the global NAND market.</p>
  <p> </p>
  <p>Getting 3D NAND to work consistently in wide operating temperatures (-40°C to 85°C) has been a challenge for some manufacturers who supply the industrial markets. The standard operating temperature of 0°C to 70°C is adequate for consumer grade, work place, server and data centres but for applications working in harsh environments or remote places this temperature range is not enough. Industrial storage providers have now had time to analyse and test 3D NAND to the point where it consistently works in wide operating temperatures and it is now available for industrial applications.</p>
  <h2>Pros and cons of 3D NAND</h2>
  <p>3D NAND flash offers the potential for higher capacity in a smaller physical space than 2D NAND. In comparison to planar NAND, 3D NAND can lower the cost per gigabyte, may improve electrical use to reduce power consumption, boost reliability, and provide higher data write performance. It represents a major leap in technology since NAND Flash was first invented by in the early 1980’s. One current disadvantage of 3D NAND vs. planar NAND is the higher manufacturing cost. The production of 3D NAND flash can take place in the same factory as planar NAND, but the layering process adds additional steps to the manufacturing process. Manufacturers (also known as semiconductors or fabs)  need to update, expand and/or add factories to accommodate 3D NAND production. As the fabs are focusing on 3D manufacture the supply of 2D NAND has dropped, hence the global shortages and higher prices during 2017.</p>
  <p> </p>
  <p>It really depends what you are using the storage in your application for. 3D NAND may be suitable but its always worth speaking to experts to get the right solution.</p>
  <h2>NAND vs. NOR</h2>
  <p>The NAND flash array is grouped into a series of 128-kbyte blocks, which are the smallest erasable entity in a NAND device. Erasing a block sets all bits to “1” (all bytes to FFh). Programming is necessary to change erased bits from a 1 to a 0. The smallest entity that can be programmed is a byte. Some NOR Flash memory can perform read-while-write operations.</p>
  <p> </p>
  <p>Although NAND can&#39;t perform read and write simultaneously, it can accomplish this at a system level using a method called shadowing, which has been used on PCs for years by loading the BIOS from the slower ROM into the higher-speed RAM.</p>
  <p> </p>
  <p>NAND&#39;s advantages are fast write (program) and erase operations, while NOR&#39;s advantages are random access and byte write capability.</p>
  <p> </p>
  <p>NOR&#39;s random access ability allows for execute in place (XiP) capability, which is often a requirement in embedded applications. The disadvantages for NAND are slow random access, while NOR is hampered by are slow write and erase performance. NAND is better suited for file applications. However, more processors include a direct NAND interface and can boot directly from NAND (without NOR).</p>
  <p> </p>
  <p>The random access time for NOR flash is specified at 0.12 µs, whereas NAND random access is significantly slower for the first byte. Once the initial access is made, however, the remaining 2111 bytes are shifted out of NAND at only 0.03 µs/byte. <br />
    The real benefits for NAND are faster program and erase times, as NAND provides over 5 Mbytes/s of sustained write performance. The block erase times are an impressive 2 ms for NAND versus 750 ms for NOR. Clearly, NAND has several significant positive attributes. However, it&#39;s not well-suited for direct random access.</p>
  <p>NOR flash requires around 41 I/O pins for a 16-bit device, while NAND devices requires only 24 pins for a comparable interface. This pin savings comes from NAND&#39;s multiplexed command, address, and data bus. A benefit of the multiplexed interface is that larger NAND devices can be supported using the same hardware design and pcb. Because the common TSOP-1 package has been used for many years, this feature lets customers migrate to higher-density NAND devices on the same pcb. Another advantage of NAND is evident in it&#39;s packaging options: NAND offers a monolithic 2-Gbit die or can support up to four stacked die, allowing an 8-Gbit device in the same TSOP-1 package. This enables one package and interface to support higher densities in the future.</p>
  <h2>NAND basic operation</h2>
  <p>The 2-Gbit NAND device is organized as 2048 blocks, with 64 pages per block.</p>
  <p> </p>
  <p>Each page has 2112 bytes total, comprised of a 2048-byte data area and a 64-byte spare area. The spare area is typically used for ECC, wear-leveling information, and other software overhead functions, although it&#39;s physically no different from the rest of the page. NAND devices are offered with either an 8- or 16-bit interface. Host data is connected to the NAND memory through a bidirectional data bus, 8 or 16 bits wide. In 16-bit mode, commands and addresses use only the lower 8 bits. The upper 8 bits are only used during data-transfer cycles.</p>
  <p> </p>
  <p>The 2-Gbyte NAND device is organized as 2048 blocks.<br />
    Erasing a block requires about 2 ms. Once the data is loaded in the register, programming a page requires about 300 µs. A page read requires approximately 25 µs, in which the page is accessed from the array and loaded into the 16,896-bit register. The register is then available for the user to clock out the data.</p>
  <p> </p>
  <p>In addition to the I/O bus, the NAND interface is comprised of six major control signals:<br />
    Chip enable (CE#): If CE is not asserted, the NAND device will remain in standby mode and not respond to any control signals.<br />
    Write enable (WE#): WE# is responsible for clocking data, address, or commands into the NAND.<br />
    Read enable (RE#): RE# will enable the output data buffers.<br />
    Command latch enable (CLE): When CLE is high, commands are latched into the NAND command register on the rising edge of the WE# signal.<br />
    Address latch enable (ALE): When ALE is high, addresses are latched into the NAND address register on the rising edge of the WE# signal.<br />
    Ready/busy (R/B#): If the NAND device is busy, the R/B# signal will be asserted low. This signal is open drain and needs a pull-up resistor. <br />
    Data is shifted into or out of the NAND register 16 or 8 bits at a time. When doing a Program operation, the data to be programmed is clocked into the data register on the rising edge of the WE#. Special commands are used to randomly access or move data around within the register to make random access easier.</p>
  <p> </p>
  <p>Data is output from the data register in a similar fashion using the RE# signal, which is responsible for outputting the current data and incrementing to the next location. The WE# and RE# clocks can run as fast as 30 ns. When RE# or CE# aren&#39;t asserted low, the output buffers will be tri-stated. This combination of CE# and RE# enables the output buffers, allowing NAND flash to share the data bus with other types of memory like NOR, SRAM, or DRAM. This feature is sometimes called &quot;chip enable don&#39;t care.&quot; The primary purpose of this reference is to accommodate older NAND devices, which require CE# to be asserted for the entire cycle.</p>
  <p> </p>
  <p>All NAND operations start supplying a command cycle. This is accomplished by placing the command on I/O bits 7:0, driving CE# low and CLE high while issuing a WE# clock. Note that commands, address, or data are clocked into the NAND device on the WE# signal&#39;s rising edge. Table 1 also shows that Most commands require a number of address cycles followed by a second command cycle. Note that with the exception of the Reset or Read Status commands, new commands shouldn&#39;t be issued if the device is busy.</p>
  <p> </p>
  <p><br />
    Looking at the addressing scheme for 2Gb NAND devices, the first and second address cycles specify the column address, which specifies the starting byte within the page. Note that because the last column location is 2112, the address of this last location would be 08h (in the second byte) and 3Fh (in the first byte). PA5:0 specify the page address within the block and BA16:6 specify the block address. While the full 5-byte address is required for most Program and Read operations, only the first and second bytes are needed for operations that randomly access data within the page. The Block Erase operation only requires the three most significant bytes (third, fourth, and fifth) to select the block.</p>
  <h2>Reset operation</h2>
  <p>As discussed previously, CE# must be low for all NAND activities. The simplest NAND command is the Reset (FFh), which doesn&#39;t require any address or second cycle. Simply assert CLE and issue a write pulse with FFh on the data bus, and a Reset operation is performed. Reset is one of two commands that can be issued while the NAND device is busy. If it&#39;s busy processing a previous command, issuing a Reset aborts the previous operation. Note that if the previous operation was an Erase or Program command, issuing a Reset aborts the command prematurely, and the desired operation doesn&#39;t complete. Because Erase and Program can be time-consuming operations, they can be aborted with a Reset and re-issued later.</p>
  <h2>Read ID operation</h2>
  <p>The Read ID (90h) command requires one dummy address cycle (00h), but doesn&#39;t need a second command cycle. After issuing the command and dummy address, the ID data can be read out by keeping CLE and ALE low and toggling the RE# signal for each byte of ID.  </p>
  <h2>Read status operation</h2>
  <p>Read Status (70h) is the second command that can be issued while the NAND device is busy. This command doesn&#39;t require an address or second command cycle. The NAND device&#39;s status can be interrogated by issuing the RE# clock signal. If the Read Status command is used to monitor the device&#39;s ready state, the command should only be issued one time and the status re-read by re-issuing the RE# clock. Alternatively, the RE# signal can be kept low waiting for the appropriate status bit. Read Status also includes the status of the write protect pin as well as the pass/fail status of the previous Program or Erase operations. It&#39;s mandatory that successful status be attained on Program or Erase operations to ensure proper data integrity.</p>
  <p> </p>
  <p>The Block Erase (60h) operation erases an entire block of 64 pages or 128 bytes total. To issue this operation, use the WE# signal to clock in the Erase command (60h) with CLE asserted. Next, clock in three address cycles, keeping ALE asserted for each address byte. The three address cycles are the most significant address cycles of Table 2, which includes the block and page addresses. The page address portion (the low order 6 bits of the third address cycle) is ignored, and only the block address portion of the three most significant bytes is used. Once the address is input completely, issue the second command (command cycle 2) of D0h, which also gets clocked in with WE# while CLE is being asserted. This confirms the erase operation, and the device goes busy for roughly 2 ms. When this operation completes, the device is ready for another command. Notice the Read Status command can be issued at any time, even when the device is busy during the erase. The processor or controller could interrogate the device using the read status command.</p>
  <h2>Program operations</h2>
  <p>Program operations can only program bits to 0, and assume that you started with a previously-erased block. If you don&#39;t want to program a bit, keep it in its erased state by setting that particular bit (or group of bits). When the Program Page (80h) command is received, the input register is reset to all 1s (internally). This lets the user input only data bytes that he wants to program with 0 bits. The Program operation starts with the 80h command, with CLE asserted. Next, drop CLE and assert ALE to input the full five address cycles.</p>
  <p> </p>
  <p>When the Program Page (80h) command is received, the input register is internally reset to all 1s, letting the user input only data bytes that he wants to program with 0 bits.<br />
    After the command and address are input, data is input to the register. Once all the data has been input, we issue the confirm command (10h) and start the programming operation. A Program operation typically requires 300 µs, although it may require up to 700 µs. It&#39;s mandatory that you read the status and check for successful operation. If the operation isn&#39;t successful, log the block and don&#39;t use it in the future. Move all data from the block to a good block.</p>
  <p> </p>
  <p>Random data input operation<br />
    The next command is the random data input command (85h). This command only requires two bytes of address followed by the data. It&#39;s useful when you want to jump around within a page, to access ECC data, for example. Random data input can be used to jump to the end of the page and write the ECC data. You can input as many address and data combinations as needed. It&#39;s only when the program confirm command (10h) is issued that the data is actually programmed to the selected page.</p>
  <p> </p>
  <p>Show is the Program command with random data input. The highlighted section shows that this command only requires two bytes of address followed by the data.<br />
    Due to the NAND page&#39;s large size, partial page programming is needed to store smaller-sized data. Each NAND page could accommodate four PC-sized 512-byte sectors. The spare area of each page provides additional storage for ECC and other information. While it&#39;s advantageous to write all four sectors at once, it&#39;s not always possible. An example of this is when you are appending a file. The file might start out as 512 bytes, with additional data coming later, making it 1024 bytes. In this case, writing the second 512 bytes would require a second page program operation to the NAND device. The maximum specification for partial page programming is eight; this would accommodate four data sectors and ECC, each programmed separately.</p>
  <p>There are two common methods for storing data and spare information in the same page (Fig. 6). The first contains a data area of 512 bytes with the spare area directly adjacent to it. The spare area in this case is 16 bytes. Therefore, a 2112-byte page could contain four 528-byte elements. The second implementation involves storing the data and spare information separately. This means the 512-byte data is stored first, and the respective spare information for that data is stored at the end of the array starting at the beginning of the spare area. The second 512 bytes is stored next to the first 512, and the associated spare area for the second 512 is stored in the next 16-byte spare area. This continues until all four 512-byte sectors are stored with their respective 16-byte spare areas.</p>
  <h2>Read operation</h2>
  <p>A read operation starts with a command (00h), followed by five address cycles, followed by the read confirm (30h). After the read transfer time (tR) of approximately 25 µs, the data is loaded into the register and ready for output. Issuing the read enable (RE#) clock lets the NAND output the first byte corresponding to the column address specified in the address. Subsequent RE# transitions output successive locations. When RE# is high (not asserted), the I/O lines are tri-stated. Also, reading past the end of the device (byte 2112 or word 1056) results in reading invalid data. Random data can be directly accessed by issuing the (05h) command, two address cycles, and a (E0h) confirmation cycle. Once the page has been read from the array, this command provides rapid access to the data.</p>
  <p> </p>
  <p>The NAND device actually has two registers: a data register and a cache register . The Page read cache mode command lets you pipeline the next sequential access from the array while outputting the previously-accessed data. This double-buffered technique allows you to hide the read access time (tR). Data is first transferred from the NAND array to the data register. If the cache register is available (not busy), the data is quickly moved from the data register to the cache register. Once it&#39;s been transferred to the cache register, the data register is available and can start to load the next sequential page from the NAND array.</p>
  <p><br />
    Shown is the page read cache mode.<br />
    A 33% performance improvement can be achieved on an 8-bit I/O device, resulting in up to 31 Mbytes/s of throughput. With the16-bit I/O device, throughput can be increased to 37 Mbytes/s, a 40% improvement over the normal Page read operation. Read cache can be especially useful during system boot-up, when large amounts of data are typically read from NAND and start-up time is critical.</p>
  <h2>Program page cache mode command</h2>
  <p>Program page cache mode provides performance improvement over normal Program page operations. This double-buffered technique lets the controller input data directly to the cache register and uses the data register as a holding register to supply the programming of the array. This frees the cache register so that the next sequential page operation can be loaded in parallel. In many applications, the programming time (tPROG) can be completely hidden. Like the page read cache mode command, the data register maintains the data through the entire programming cycle. This frees up the cache register so that it can start receiving the next page of data from the controller.</p>
  <p> </p>
  <p>Read for internal data move (00h, 35h), or copy back, is another useful system-level command. It provides the ability to move data from one page to another internally without leaving the NAND device. The Read for internal data move operation transfers the data read from the NAND array to the cache register. It can then be programmed into another page of the NAND device. This is beneficial in cases where the controller needs to move data out of a block before erasing that block. It&#39;s also possible to modify the data read before the program operation starts. This could be useful if you wanted to change the data before programming. This feature allows data to be moved around within the NAND device without tying up the processor or the I/O bus.</p>
  <p> </p>
  <p>Connecting NAND to a processor<br />
    There are significant advantages to selecting a processor or a controller with a built-in NAND interface. If this option isn&#39;t available, it&#39;s possible to design a glueless interface between the NAND and almost any processor. The main difference between NAND and NOR flash is the multiplexed address and data bus. This bus is used to specify commands, address, or data. The CLE signal specifies command cycles, while the ALE signal specifies address cycles. Using these two control signals, it&#39;s possible to select a command, address, or data cycle. Connecting ALE to the processor&#39;s address bit five and CLE to the processor&#39;s address bit four enables the selection of either command, address, or data simply by changing the address that the processor outputs. This allows CLE and ALE to be asserted automatically at the appropriate time.</p>
  <p> </p>
  <p>To supply a command, the processor outputs the intended command on the data bus and output address 0010h. To supply any number of address cycles, the processor simply needs to output the intended NAND address sequence to processor address 0020h. Note that many processors can specify several timing parameters around the processor&#39;s write signal, which is critical for proper timing. Using this technique, you can access commands, address, and data directly from the processor without any glue logic. In this case, ECC would have to be handled in the software.</p>
  <h2>Multi-level cell</h2>
  <p>A Multi-level cell (MLC) stores two bits per cell, versus traditional SLCs that can only store one bit. There are obvious density advantages for MLC technology. However, it doesn&#39;t offer the speed or reliability of its SLC counterpart. Because of this, SLC is used in most media cards and wireless applications, while MLC devices are typically found in consumer and other low-cost products.</p>
  <p> </p>
  <p><span style="font-size: 11pt;">As mentioned, NAND requires ECC to ensure data integrity. NAND flash includes extra storage on each page. The extra storage is the spare area of 64 bytes (16 bytes per 512-byte sector). This area can store the ECC code as well as other information like wear-leveling or logical-to-physical block-mapping. ECC can be performed in hardware or software, but hardware implementation provides an obvious performance advantage. During a programming operation, the ECC unit calculates the error-correcting code based on the data stored in the sector. The ECC code for the respective data area is then written to the respective spare area. When the data is read out, the ECC code is also read, and the reverse operation is applied to check that the data is correct.</span></p>
  <p> </p>
  <p>It&#39;s possible for the ECC algorithm to correct data errors. The number of errors that can be corrected depends on the correction strength of the algorithm used. Including ECC in hardware or software provides a robust system-level solution. Simple Hamming codes provide the easiest hardware implementation, but can only correct single-bit errors. Reed-Solomon codes can provide a more robust error correction and are used on many of today&#39;s controllers. Also, BCH codes are becoming popular due to their improved efficiency over Reed-Solomon.</p>
  <p> </p>
  <p>Software is needed to perform the NAND flash&#39;s block management. This software is responsible for wear-leveling or logical-to-physical mapping. The software may also provide the ECC code if the processor does not include ECC hardware.</p>
  <p> </p>
  <p>It&#39;s important to read the status register after a program or erase operation, as it confirms successful completion of the operation. If the operation wasn&#39;t successful, the block should be marked bad and no longer used. Previously programmed data should be moved out of the bad block into a new (good) block. The spec for a 2-Gbyte NAND device states that it could have up to 40 bad blocks, a number that applies throughout the device&#39;s life (nominally 100,000 program/erase cycles). Due mostly to their large die size, NAND devices can ship from the factory with some bad blocks. The software managing the device is responsible for mapping the bad blocks and replacing them with good blocks.</p>
  <p> </p>
  <p>The factory marks these blocks in such a way that the software can scan all the blocks to determine which are good and which aren&#39;t. The bad-block mark is fixed at the first location in the spare area (column location 2048). If location 2048 in either page 0 or 1 is &quot;non-FF,&quot; then the block should be considered bad and mapped out of the system. The initialization software simply needs to scan through all blocks to determine which are bad and then build a table of these bad blocks for future reference.</p>
  <p> </p>
  <p>It&#39;s important to take special care not to erase the bad-block marks. The factory tests NAND over a wide range of temperatures and voltages. Some blocks that are marked bad by the factory may be functional at certain temperatures or voltages but could fail in the future. If the bad-block information is erased, it can&#39;t be recovered.</p>
  <p> </p>
  <p> </p>
  <p><a href="Introduce.htm">Introduce</a></p>
</body>
</html>